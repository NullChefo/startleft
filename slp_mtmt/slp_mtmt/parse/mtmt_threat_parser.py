import re
from enum import Enum

from otm.otm.entity.component import Component
from otm.otm.entity.mitigation import Mitigation, MitigationInstance
from otm.otm.entity.threat import Threat, ThreatInstance
from slp_mtmt.slp_mtmt.entity.mtmt_entity_threatinstance import MTMThreat
from slp_mtmt.slp_mtmt.mtmt_entity import MTMT


def get_threat_description(threat: MTMThreat):
    return remove_trailing_dot(re.split("\\.\\s*Consider", threat.long_description)[0])


def get_mitigation_description(threat: MTMThreat):
    description = re.match(".*(Consider.+\\.)", threat.long_description)
    return remove_trailing_dot(description.group(1)) if description else None


def get_first_sentence(message: str):
    return message.split(".")[0]


def remove_trailing_dot(message: str):
    return message.rstrip(".") if message else None


def add_threat_to_component(threat: MTMThreat, threat_instance: ThreatInstance, components: [Component]):
    component: Component = next(
        (component for component in components if component.id == threat.destination_component_id), None)

    if component is not None:
        component.add_threat(threat_instance)


class MTMThreatParser:
    def __init__(self, source: MTMT):
        self.__source = source

    def parse(self, components: [Component]):
        threats: [Threat] = []
        mitigations: [Mitigation] = []

        for threat in self.__source.threats:
            otm_threat = Threat(threat.id, threat.title, threat.threat_category, get_threat_description(threat))
            threats.append(otm_threat)

            threat_instance: ThreatInstance = ThreatInstance(threat.id, threat.threat_state)

            if threat.threat_state != MitigationState.NOT_APPLICABLE.value:
                mitigation_instance: MitigationInstance = MitigationInstance(
                    threat.id,
                    MitigationState.by_value(threat.threat_state).name
                )

                if threat.from_azure_template:
                    mitigations.append(
                        Mitigation(
                            threat.id,
                            get_first_sentence(threat.possible_mitigations),
                            remove_trailing_dot(threat.steps) or remove_trailing_dot(threat.possible_mitigations)
                        )
                    )

                    threat_instance.add_mitigation(mitigation_instance)
                else:
                    mitigation_description = get_mitigation_description(threat)

                    if mitigation_description:
                        mitigations.append(
                            Mitigation(
                                threat.id,
                                get_first_sentence(mitigation_description),
                                remove_trailing_dot(mitigation_description)
                            )
                        )

                        threat_instance.add_mitigation(mitigation_instance)

                add_threat_to_component(threat, threat_instance, components)

        return threats, mitigations


class MitigationState(Enum):
    IMPLEMENTED = "Mitigated"
    REQUIRED = "NeedsInvestigation"
    RECOMMENDED = "AutoGenerated"
    NOT_APPLICABLE = "NotApplicable"

    @classmethod
    def by_value(cls, value: str):
        for mitigation_state in MitigationState:
            if mitigation_state.value == value:
                return mitigation_state

        raise ValueError(f"No enum value for {value}")
